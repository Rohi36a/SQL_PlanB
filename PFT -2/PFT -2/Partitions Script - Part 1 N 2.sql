CREATE DATABASE Employe_ResidnceDB
ON PRIMARY
( NAME = Primary_Metadata,
    FILENAME = 'E:\Primary_DATA.mdf',
    SIZE = 10,
    MAXSIZE = 50,
    FILEGROWTH = 5 ),
FileGroup CANADA_FG
( NAME = CANADA_data,
    FILENAME = 'E:\CANADA_data.ndf',
    SIZE = 10,
    MAXSIZE = 50,
    FILEGROWTH = 5 ),
FileGroup INDIA_FG
( NAME = INDIA_data,
    FILENAME = 'E:\INDIAdata.ndf',
    SIZE = 10,
    MAXSIZE = 50,
    FILEGROWTH = 5 ),
FileGroup USA_FG
( NAME = USA_Data,
    FILENAME = 'E:\USA_Data.ndf',
    SIZE = 10,
    MAXSIZE = 50,
    FILEGROWTH = 5 )

use Employe_ResidnceDB


-- REQUIREMENT: TO DIVIDE THE DATA IN THIS DATABASE BASED ON EMPLOYEE COUNTRY OF RESIDENCE
-- REQUIREMENT: HOW TO PLACE THE TABLE DATA INTO MULTIPLE FILEGROUPS? 

/*
STEPS TO IMPLEMENT PARTITIONS:
		STEP 1: DEFINE PARTITION FUNCTION
		STEP 2: DEFINE PARTITION SCHEME
		STEP 3: CREATE THE TABLE USING ABOVE PARTITION SCHEME
				OR
				REBUILD THE EXISTING TABLE USING ABOVE PARTITION SCHEME
*/

-- PARTITION FUNCTION : AN OBJECT USED TO SPECIFY THE CONDITION USED FOR DATA DIVISION

-- PARTITION SCHEME : AN OBJECT USED TO CONTROL THE PLACEMENT OF DATA FROM ABOVE PARTITION FUNCTION

CREATE PARTITION FUNCTION partFunction(varchar(30))
AS RANGE 
FOR VALUES ('CANADA', 'INDIA', 'USA')			-- BOUNDARY VALUES : 3
												-- TOTAL NUMBER OF RANGES : 4

CREATE PARTITION SCHEME partScheme
AS PARTITION partFunction 
TO ('CANADA_FG', 'INDIA_FG', 'USA_FG', 'PRIMARY')


CREATE TABLE Employee_Info
(
Emp_ID int,
Emp_FName varchar(15),
Emp_LName varchar(12),
Emp_CNTRY varchar(30)  
	check (Emp_CNTRY IN ('CANADA', 'INDIA','USA')),
Emp_Sal int
) ON partScheme(Emp_CNTRY)


insert into Employee_Info values(1001,'Shekar',NULL,'USA',190856)
insert into Employee_Info values(1002,'Muni',NULL,'INDIA',130876)
insert into Employee_Info values(1003,'Muni Shekar',NULL,'CANADA',590876)
insert into Employee_Info values(1004,'Munish',NULL,'CANADA',490876)
insert into Employee_Info values(1005,'john',NULL,'INDIA',290876)
insert into Employee_Info values(1006,'johny',NULL,'INDIA',140876)
insert into Employee_Info values(1007,'jeff',NULL,'USA',199871)


SELECT * FROM Employee_Info   -- OBSERVE THE ORDER OF DATA BASED ON PARTITION


SELECT * FROM Employee_Info
WHERE Emp_CNTRY IN ('INDIA', 'USA')


SELECT * FROM Employee_Info
WHERE Emp_CNTRY IN ('CANADA')


-- HOW TO VERIFY IF A TABLE IS PARTITIONED?
SELECT * FROM SYS.PARTITIONS			-- THIS REPORTS ALL PARTITIONS IN THE DATABASE

SELECT * FROM SYS.PARTITIONS	WHERE OBJECT_ID = OBJECT_ID('Employee_Info')  -- Heap or Binary Tree





-- SCENARIO 2: WHAT IF TABLE ALREADY EXIST?
CREATE TABLE Employee_InfoV2
(
Emp_ID int,
Emp_FName varchar(15),
Emp_LName varchar(12),
Emp_CNTRY varchar(30)  
	check (Emp_CNTRY IN ('CANADA', 'INDIA','USA')),
Emp_Sal int
) ON [PRIMARY]


insert into Employee_InfoV2 values(1001,'Shekar',NULL,'USA',190856)
insert into Employee_InfoV2 values(1002,'Muni',NULL,'INDIA',130876)
insert into Employee_InfoV2 values(1003,'Muni Shekar',NULL,'CANADA',590876)
insert into Employee_InfoV2 values(1004,'Munish',NULL,'CANADA',490876)
insert into Employee_InfoV2 values(1005,'john',NULL,'INDIA',290876)
insert into Employee_InfoV2 values(1006,'johny',NULL,'INDIA',140876)
insert into Employee_InfoV2 values(1007,'jeff',NULL,'USA',199871)


SELECT * FROM Employee_InfoV2 


SELECT * FROM SYS.PARTITIONS WHERE object_id = OBJECT_ID('Employee_InfoV2')

-- HOW TO PARTITION THE UNPARTITIONED TABLE?
-- PARTITIONING THE TABLE MEANS DIVING THE TABLE DATA INTO MULTIPLE FILEGROUPS
-- PARTITIONING THE TABLE MEANS DIVING THE TABLE DATA INTO MULTIPLE FILES ACROSS MULTIPLE FILEGROUPS
-- MEANS, WE NEED TO SPLIT THE TABLE DATA INTO MULTIPLE DATA PAGES ACROSS MULTIPLE FILES

-- MEANS, HOW TO MOVE EXISTING DATA PAGES FROM ONE COMMON FILEGROUP/FILE TO MULTIPLE FILES / FILEGROUPS?

-- WHICH STRUCTURE CONTROLS DATA PAGES? CLUSTERED INDEX PAGES
-- PARTITIONING THE TABLE MEANS, PARTITIONING THE DATA PAGES
-- DATA PAGES CAN BE CONTROLLED BY CLUSTERED INDEX PAGES
-- SO, IT IS ENOUGH TO PARTITION THE CLUSTERED INDEX PAGES. 


CREATE CLUSTERED INDEX CIX_EMP_ID
ON Employee_InfoV2(EMP_ID)
ON partScheme(Emp_CNTRY)


-- now, verify that your table is partitioned.
SELECT * FROM SYS.PARTITIONS WHERE object_id = OBJECT_ID('Employee_InfoV2')


-- PARTITION SPLIT  : A MECHANISM TO ADD NEW PARTITIONS TO EXISTING LIST.
						--TABLE DATA IS AUTOMATICALLY REARRANGED.

ALTER PARTITION FUNCTION  partFunction()
SPLIT RANGE ('UK')


-- PARTITION MERGE : A MECHANISM TO REDUCE THE EXISTING PARTITIONS.
						--TABLE DATA IS AUTOMATICALLY REARRANGED.

ALTER PARTITION FUNCTION  partFunction()
MERGE RANGE ('CANADA')






-- ANOTHER EXAMPLE:
-- HOW TO DEFINE PARTITIONS?
			-- STYLE 1: RANGE LEFT
			-- STYLE 2: RANGE RIGHT


			SELECT * FROM SYS.partition_functions
CREATE PARTITION FUNCTION myRangePF1 (int)  
AS RANGE LEFT FOR VALUES ( 1, 100, 1000 );  
GO						

CREATE PARTITION FUNCTION myRangePF1 (int)  
AS RANGE RIGHT FOR VALUES ( 1, 100, 1000 );  
GO			


-- HOW TO SPLIT PARTITIONS?
ALTER PARTITION FUNCTION myRangePF1() SPLIT RANGE(150)

-- HOW TO MERGE PARTITIONS?
ALTER PARTITION FUNCTION myRangePF1() MERGE RANGE(150)













-- ANOTHER EXAMPLE:


















--Merge the partitions between boundary_values 1 and 100  
--and between boundary_values 100 and 1000 to create one partition  
--between boundary_values 1 and 1000.  

CREATE PARTITION FUNCTION myRangePF1 (int)  
AS RANGE LEFT FOR VALUES ( 1, 100, 1000 );  
GO  



ALTER PARTITION FUNCTION myRangePF1 ()  
MERGE RANGE (100); 


ALTER PARTITION FUNCTION myRangePF1 ()  
SPLIT RANGE (150); 

