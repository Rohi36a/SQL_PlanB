/*
COMMON TABLE EXPRESSION (CTE) :
			
			A MEMORY OBJECT (VOLATILE / TEMPORARY) USED TO CREATE A REFERENCE TO ANY QUERY.

			THE RESULT OF THE QUERY IS LOADED INTO MEMORY. 
			OPERATIONS ON PERFORMED	ON THIS MEMORY COPY. "IN-MEMORY PROCESSING"

			BY DEFAULT, THE MINIMUM MEMORY ALLOCATION FOR ANY QUERY IS 1 MB.
			BUT FOR CTEs, ADDITIONAL MEMORY IS PRE-ALLOCATED FOR "CACHING" THE DATA.
			MEMORY OPERATES FASTER COMPARED TO DISK. 

SYNTAX:		WITH <CTEReferenceName>
			AS
			(
				ANY VALID SELECT QUERY ...
			)
			ATLEAST ONE OPERATION ON THE CTE	
			
			POSSIBLE OPERATIONS ON CTE: INSERT, UPDATE, DELETE, SELECT, MERGE	
*/


USE PRODUCTDATABASE

SELECT ProductKey,EnglishProductName,Class,Color,ListPrice FROM PRODUCTS_DATA
WHERE
Class = 'M'


-- HOW TO STORE THE ABOVE QUERY DATA REFERENCE IN MEMORY? FOR FASTER UPDATES/DELETES, ETC..
-- SCENARIO : ASSUME HUGE LIST OF PRODUCTS DATA. WE NEED TO ENSURE FASTEST POSSIBLE UPDATES!
-- SOLUTION: CACHE THE QUERY & ITS RESULT INTO MEMORY USING "CTE". PERFORM OPERATIONS ON THIS CTE COPY.
-- RESULT : ANY OPERATIONS WE PERFORM ON THE CTE automatically AFFECT THE BASE TABLE
WITH CTE 
AS
	(
	SELECT * FROM PRODUCTS_DATA 
	WHERE 
	ListPrice IS NULL
	)
UPDATE CTE
SET ListPrice = 100
WHERE ListPrice IS NULL 


-- VERIFY ABOVE RESULT:  

	SELECT * FROM PRODUCTS_DATA 
	WHERE 
	ListPrice IS NULL			-- THE ROW COUNT IS ZERO (0)


	SELECT * FROM PRODUCTS_DATA 
	WHERE 
	ListPrice = 100


-- ANOTHER EXAMPLE:
WITH CTE 
AS
	(
	SELECT * FROM PRODUCTS_DATA 
	WHERE 
	ListPrice = 100
	)
SELECT * FROM CTE 


SELECT * FROM CTE   -- ERROR




-- FOR COMPILATION & OPTIMIZATION :  STORED PROCEDURE
CREATE PROCEDURE usp_UpdateListPrice (@ExistingPrice float, @NewPrice float)
AS
BEGIN				/*START OF STORED PROCEDURE */
BEGIN TRY
WITH CTE 
AS
	(
	SELECT * FROM PRODUCTS_DATA 
	WHERE ListPrice = @ExistingPrice
	)
UPDATE CTE			-- THIS MEANS, WE ARE UPDATING THE BASE TABLE
SET ListPrice = @NewPrice
END TRY
BEGIN CATCH
	PRINT 'ERROR DURING PRICE UPDATE'
	;THROW
END CATCH
END				/*START OF STORED PROCEDURE */



-- HOW TO EXECUTE ABOVE SP?
EXEC usp_UpdateListPrice @ExistingPrice = 100, @NewPrice = 200






/*
SCENARIO : YOU WERE GIVEN A LEGACY TABLE. YOU ARE REQUESTED TO COMPUTE THE ROW NUMBER FOR EACH ROW
AND UPDATE THE SAME TO A NEW COLUMN YOU ADDED TO THE TABLE
*/

CREATE TABLE tbl_ScopeIdenTity
(
ID_COL INT identity(1000001,1),
Value_Col INT default 100,
RANK_Col INT
)

INSERT INTO tbl_ScopeIdenTity DEFAULT VALUES
INSERT INTO tbl_ScopeIdenTity DEFAULT VALUES
INSERT INTO tbl_ScopeIdenTity DEFAULT VALUES
INSERT INTO tbl_ScopeIdenTity DEFAULT VALUES
INSERT INTO tbl_ScopeIdenTity DEFAULT VALUES
INSERT INTO tbl_ScopeIdenTity DEFAULT VALUES
INSERT INTO tbl_ScopeIdenTity DEFAULT VALUES

SELECT * FROM tbl_ScopeIdenTity

SELECT * FROM tbl_ScopeIdenTity
-- REQ 1: HOW TO GENERATE SEQUENCE OF NUMBERS?
SELECT *, ROW_NUMBER() OVER (ORDER BY ID_COL) AS SEQUENCE_VALUE FROM tbl_ScopeIdenTity

-- REQ 2: HOW TO UPDATE THESE SEQUENCE OF NUMBERS TO RANK_COLUMN?
 UPDATE tbl_ScopeIdenTity
 SET RANK_Col = SubQuery.SequenceNumber
 FROM
 (
 SELECT * ,ROW_NUMBER() OVER (ORDER BY ID_COL) AS SequenceNumber from tbl_ScopeIdenTity
 ) AS SubQuery
 inner join
 tbl_ScopeIdenTity AS T
 ON
 SubQuery.ID_COL = T.ID_COL 
 AND
 SubQuery.Value_Col = T.Value_Col  



 -- ISSUE 1 WITH ABOVE QUERY : WHAT IF THE TABLE HAS MORE NUMBER OF COLUMNS? 
							   -- NEED TO COMPARE ALL THE COLUMNS!

 -- ISSUE 2 WITH ABOVE QUERY:  WHAT IF ID AND VALUE COLUMNS ARE SAME FOR MULTIPLE ROWS?
							   --WE END UP WITH DUPLICATE ROW NUMBER !

-- RESET THE TABLE TO BASE VALUE : 
UPDATE tbl_ScopeIdenTity SET RANK_COL = NULL 

SELECT * FROM tbl_ScopeIdenTity


-- FINAL SOLUTION VERSION 1: 
-- AVOID SUB QUERIES
-- AVOID SELF JOINS

-- HOW? USING COMMON TABLE EXPRESSIONS (CTE).

 WITH CTE
 AS
 (
 SELECT * ,ROW_NUMBER() OVER (ORDER BY ID_COL) AS SequenceNumber from tbl_ScopeIdenTity
 ) 
 UPDATE CTE 
 SET RANK_Col = SequenceNumber



 -- FINAL SOLUTION VERSION 2:
 CREATE PROC USP_UPDATE_TABLE
 AS
 BEGIN
 WITH CTE
 AS
 (
 SELECT * ,ROW_NUMBER() OVER (ORDER BY ID_COL) AS SequenceNumber from tbl_ScopeIdenTity
 ) 
 UPDATE CTE 
 SET RANK_Col = SequenceNumber
 END 

 EXEC USP_UPDATE_TABLE


 
/*	RECURSIVE CTEs
	A CTE CALLING ANOTHER CTE INSIDE IT.

	WITH cte_name (column1, column2, …)
	AS
	(
		cte_query_definition -- Anchor member
		UNION ALL
		cte_query_definition -- Recursive member; references cte_name.
	)
	ANY OPERATION ON ABOVE CTE_NAME
*/

-- RECURSIVE CTEs: DEMAND MORE MEMORY. TO BE AVOIDED.



WITH CTE
AS     (
		SELECT 1 AS SeqNumber	-- ANCHOR MEMBER
        UNION ALL
        SELECT SeqNumber + 1	-- RECURSIVE MEMBER
        FROM   cte
        WHERE  SeqNumber < 50    -- TERMINATION CHECK
       )
SELECT *
FROM   cte;




/*
JOIN OPTIONS :  THESE ARE ADDITIONAL KEYWORDS TO BE SPEICIFIED WHILE PERFORMING JOINS
				USED TO ENHANCE THE JOIN PERFORMANCE
				MOSTLY USED FOR JOINING MORE THAN TWO TABLES.

				TYPES:
				HASH JOIN	: APPLICABLE TO JOIN HELP TABLES. UNINDEXED TABLES.
				MERGE JOIN  : APPLICABLE TO JOIN TABLES WITH BIGGER DATA. INTERNAL SORT OPERATIONS TAKES PLACE.
				LOOP JOIN   : APPLICABLE TO JOIN TABLES WITH SMALLER DATA.
*/

-- QUERY 1: HASH JOIN USAGE
SELECT * FROM SALES_DATA  AS S
JOIN
TIME_DATA  AS T
ON
S.[OrderDateKey] = T.TimeKey
JOIN
PRODUCTS_DATA  AS P
ON
S.PRODUCTKEY =  P.PRODUCTKEY 
ORDER BY S.SALESAMOUNT DESC
OPTION (HASH JOIN)





-- QUERY 2: LOOP JOIN USAGE
SELECT * FROM SALES_DATA  AS S
JOIN
TIME_DATA  AS T
ON
S.[OrderDateKey] = T.TimeKey
JOIN
PRODUCTS_DATA  AS P
ON
S.PRODUCTKEY =  P.PRODUCTKEY 
ORDER BY S.SALESAMOUNT DESC
OPTION (LOOP JOIN)




-- QUERY 3: MERGE JOIN USAGE
SELECT * FROM SALES_DATA  AS S
JOIN
TIME_DATA  AS T
ON
S.[OrderDateKey] = T.TimeKey
JOIN
PRODUCTS_DATA  AS P
ON
S.PRODUCTKEY =  P.PRODUCTKEY 
ORDER BY S.SALESAMOUNT DESC
OPTION (MERGE JOIN)









WITH CTE
AS     (
		SELECT 1 AS n	-- ANCHOR MEMBER
        UNION ALL
        SELECT n + 1	-- RECURSIVE MEMBER
        FROM   cte
        WHERE  n < 500    -- TERMINATION CHECK
       )
SELECT *
FROM   cte
OPTION (MAXRECURSION 0);



/*
Invocation – This is the statement using the CTE.
Anchor Member – This portion executes first, and is only called once.
Recursive Member – The portion of the query is repeatedly executed until no rows are returned. The results of each execution are unioned with the prior results.
Termination Check – The termination check ensures the query stops.
*/


/*
PRECUATIONS FOR USING RECURSIVE CTEs:
		1. ATLEAST ONE ANCHOR ELEMENT IS MANDATORY.
	
		2. CTE CAN BE REFERENCED IN FROM CLAUSE - ONLY ONCE

		3. GROUP BY, HAVING, DISTINCT, TOP, FULL JOIN, LEFT JOIN, RIGHT JOIN ARE NOT ALLOWED IN RECURSIVE CTE 
*/




